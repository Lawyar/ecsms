#pragma once

#include <IExecuteResult.h>
#include <IFile.h>
#include <DataType/SQLDataType.h>

#include <memory>
#include <variant>

//------------------------------------------------------------------------------
/**
  Статус соединения
*/
//---
enum class ConnectionStatus
{
	Ok,     ///< Соединение успешно установлено
	Bad,    ///< Ошибка установки соединения
	Unknown ///< Неизвестный статус
};

/// Тип аргумента для выполнения метода Execute
using ExecuteArgType = std::variant<std::string, std::vector<char>>;

//------------------------------------------------------------------------------
/**
  Интерфейс соединения.
  При многопоточной работе с БД рекомендуется для каждого потока создавать
  свой объект соединения (в противном случае потоки будут выстраиваться в очередь).
*/
//---
class IConnection
{
public:
	/// Деструктор
	virtual ~IConnection() = default;

public:
	/// Валидно ли соединение
	virtual bool IsValid() const = 0;
	/// Получить статус соединения
	virtual ConnectionStatus GetStatus() const = 0;

	/// Выполнить запрос.
	/// Запрос может содержать несколько SQL команд, тогда они автоматически будут выполнены
	/// в рамках одной транзакции, кроме случаев, когда команды для разбиения на транзакции
	/// не присутствуют явно (посредством добавления команд BEGIN/COMMIT в текст запроса query или
	/// посредством вызова методом BeginTransaction/CommitTransaction).
	virtual IExecuteResultPtr Execute(const std::string & query) = 0;

	/// Открыть транзакцию
	virtual IExecuteResultStatusPtr BeginTransaction() = 0;
	/// Закрыть транзакцию с применением изменений
	virtual IExecuteResultStatusPtr CommitTransaction() = 0;
	/// Отменить транзакцию (без применения изменений)
	virtual IExecuteResultStatusPtr RollbackTransaction() = 0;

public:
	/// Создать удаленный файл.
	/// Метод может вызываться как внутри транзакции, так и не в ней.
	/// При вызове внутри транзакции действуют обычные правила транзакции:
	/// если транзакция не была завершена фиксацией или была завершена отменой, то файл не создатся.
	/// ПРЕДУПРЕЖЕДЕНИЕ: Последующая работа с удаленным файлом возможна только в рамках транзакции.
	virtual IFilePtr CreateRemoteFile() = 0;
	/// Удалить файл.
	/// Метод может вызываться как в рамках транзакции, так и не в них.
	/// При вызове внутри транзакции действуют обычные правила транзакции:
	/// если транзакция не была завершена фиксацией или была завершена отменой, то файл не создатся.
	virtual bool DeleteRemoteFile(const std::string & filename) = 0;
	/// Получить файл.
	/// ПРЕДУПРЕЖЕДЕНИЕ: Последующая работа с удаленным файлом возможна только в рамках транзакции.
	/// \return Возвращает nullptr в случае,
	///         если передано имя файла, которое не соответствует правилам именования,
	///         или если соединение невалидно.
	///         В противном случае функция возвращает ненулевой указатель. При этом полученный файл может
	///         не существовать - это проверяется на этапе его открытия методом IFile::Open.
	virtual IFilePtr GetRemoteFile(const std::string & filename) = 0;

protected:
	// todo: IConnection::Execute перегрузка с бинарными данными
	// Данный код на данный момент не используется и поэтому не тестировался,
	// так что перемещу его пока в protected-секцию.

	/// Выполнить запрос с аргументами. Запрос не может содержать более одной SQL-команды.
	/// \param query Строка в запросом. Аргументы в запросе обозначаются знаком доллара с последующим номером аргумента,
	///              начиная с единицы. Пример запроса: "INSERT INTO table VALUES($1, $2);".
	/// \param args Массив аргументов, каждый из которых может быть либо текстовой строкой, либо массивом байт.
	/// \param resultFormat Формат, в котором будет представлен результат (бинарный или текстовый)
	/// \param types Массив типов аргументов.
	///              Если передан пустой массив, то типы аргументов будут вычислены автоматически.
	///              Иначе будет предпринята попытка привести аргументы к требуемым типам.
	///              В качестве типа аргумента может быть указан неизвестный тип (SQLDataType::Unknown) - в этом
	///              случае тип этого аргумента будет вычислен автоматически.
	virtual IExecuteResultPtr Execute(const std::string & singleCommand,
		const std::vector<ExecuteArgType> & args,
		const ResultFormat resultFormat = ResultFormat::Text,
		const std::vector<SQLDataType> & types = {}) = 0;
};

/// Указатель на IConnection
using IConnectionPtr = std::shared_ptr<IConnection>;
